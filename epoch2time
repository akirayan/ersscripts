#!/usr/bin/env python3
# by endoaki@jp.ibm.com 2017-05-18
# added timezone by endo@isskk.co.jp 2025-11-27
#
import sys
import datetime
import re

# ----- Parse CLI options -----
tz_output = datetime.timezone.utc   # default: UTC

args = sys.argv[1:]
while args:
    if args[0] == "-z":
        if len(args) < 2:
            print("Error: -z requires an offset like +0900", file=sys.stderr)
            sys.exit(1)

        offset_str = args[1]

        # Validate +HHMM / -HHMM
        if not re.match(r"^[+-]\d{4}$", offset_str):
            print("Error: timezone offset must be like +0900 or -0500", file=sys.stderr)
            sys.exit(1)

        sign = 1 if offset_str[0] == "+" else -1
        hours = int(offset_str[1:3])
        minutes = int(offset_str[3:5])

        tz_output = datetime.timezone(
            sign * datetime.timedelta(hours=hours, minutes=minutes)
        )

        args = args[2:]
    else:
        print(f"Unknown option: {args[0]}", file=sys.stderr)
        sys.exit(1)

# ----- Read epoch from stdin -----
data = sys.stdin.read().strip()
if not data:
    print("Error: no epoch input", file=sys.stderr)
    sys.exit(1)

try:
    epoch = float(data)
except ValueError:
    print(f"Error: invalid epoch '{data}'", file=sys.stderr)
    sys.exit(1)

# ----- Convert epoch → datetime -----
dt = datetime.datetime.fromtimestamp(epoch, tz=datetime.timezone.utc)

# Convert to output timezone
dt = dt.astimezone(tz_output)

# ----- Format output -----
if tz_output == datetime.timezone.utc:
    # UTC → use "Z"
    print(dt.strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + "Z")
else:
    # Non-UTC → include offset
    print(dt.strftime("%Y-%m-%dT%H:%M:%S.%f")[:-3] + dt.strftime("%z"))
